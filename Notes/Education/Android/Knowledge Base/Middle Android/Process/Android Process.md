Процесс это и есть наше приложение, когда OS Android выделает ресурсы для нашего процесса она так же выделяет основной поток(UI thread). 

В системе Android есть 4 основных компонента: Activity, Content Provider, Broadcast Receiver, Service, компонент который был запущен с помощью них, присоединяется к процессу в котором находиться тот компонент который его запустил 

Система Android автоматически распределяет процессы для запуска компонента, но так же можно в Manifest прописать в каком процессе нужно запустить компонент 

Приоритеты процессов: 
1. Тот который в данный момент отображается на экране 
2. Те компоненты которые на находятся на переднем плане но все же видны пользователю(Dialog and etc) 
3. Service 
4. Процессы у которых вызван onStop 

Изменять и модифицировать view ВОЗМОЖНО из не UI потока! - так как функция которая проверяет поток на его соответствие с UI вызывается в методе onResume, и если в этом методе до вызова super поставить Thread.sleep то за это время можно изменять данные view не из UI потока!

Вместо использования native Thread, раньше использовали AsyncTask, пример кода: 
```Kotlin
class CityTask: AsyncTask<String, Int, String>() {  
    override fun onPreExecute() {  
	    //Настройка процесса до того как поток начал свою работу 
        super.onPreExecute()  
    }  
  
    override fun doInBackground(vararg params: String?): String {  
	    //Поток выполняет свою основную работу 
        TODO("Not yet implemented")  
    }  
  
    override fun onCancelled() {
	    //Поток был отменен   
        super.onCancelled()  
    }  
  
    override fun onPostExecute(result: String?) {  
	    //Поток выполнил свою работу и в этом методе можно очищать ресурсы 
        super.onPostExecute(result)  
    }  
}
```

Остановить поток в Java напрямую нельзя, можно лишь порекомендовать JVM что бы она остановила поток методом Thread.interrupted()

Deadlock - это когда 2 и более потока захватывают ресурсы которые нужны каждому из них и так как ни один из потоков свою задачу выполнить не может так как ресурсы заблокированы друг другом 

Гонка потоков - когда 2 и более потока изменяют значения одних и тех же абстракций  

synchronized - синхронизирует все потоки и выполняет их по очереди 

@Volatile int count; - когда jvm исполняет какой то код(допустим метод), то переменную которую она использует она сохраняет в кэш L1 уровня и работает конкретно с ней, если пометить переменную как @Volatile то теперь мы будем обращаться не в кэш а в оперативную память 

Далее идут методы у объекта Objects: 
- wait() - захватывает mutex у объекта и засыпает, просыпается только тогда когда мы у этого объекта вызовем метод notify или notifyAll 
- notify/notifyAll как-рас таки заставляет пробудиться все потоки которые были заморожены во время вызова метода wait()
ps: эти методы должны быть вызваны только в скопе synchronized так как это способ работы с mutex у объекта 